import express from "express";
import cors from 'cors';
import Database from "better-sqlite3";
import path from "path";
import crypto from "crypto";


// ====== 型定義（発注 DTO） ======
type SubmitLineDto = {
  itemId: string;
  qty: number;
  unitPrice: number;
  amount: number;
  vendorId: string;
};

type SubmitDto = {
  storeId: string;
  vendorMode: string;      // "all" など
  vendorId: string | null;
  orderDate: string;
  taxRate: number;
  lines: SubmitLineDto[];
};


// === DB ファイルパス ===
const DB_PATH =
  process.env.DB_PATH || path.resolve(__dirname, "..", "db", "data.sqlite");

// === DB オープン ===
const db = new Database(DB_PATH, { fileMustExist: true });

// === Express アプリ ===
const app = express();
app.use(cors());
app.use(express.json({ limit: "2mb" }));

// ====== Utils ======
// --- helper: table existence ---
function hasTable(name: string): boolean {
  try {
    // sqlite_master を見るのが手軽で高速
    const row = db
      .prepare(`SELECT name FROM sqlite_master WHERE type='table' AND name=?`)
      .get(name) as { name?: string } | undefined;
    return !!row?.name;
  } catch {
    return false;
  }
}

// 受注→出荷の集計（orders.order_date / order_lines.qty, unit_price を使用）
// vendor_weekly_rules は曜日別カラム *_sun..*_sat から CASE で取得
const AGG_SQL = `
WITH src AS (
  SELECT
    COALESCE(o.vendor_id, ol.vendor_id) AS vendor_id,
    o.store_id                           AS destination_id,  -- ← ここを固定
    o.order_date                         AS order_date,
    ol.item_id                           AS item_id,
    COALESCE(ol.qty, 0)                  AS qty,
    COALESCE(ol.unit_price, 0)           AS unit_price
  FROM orders o
  JOIN order_lines ol ON ol.order_id = o.id
),
vwr AS (
  SELECT vendor_id,
         lead_time_days_sun, lead_time_days_mon, lead_time_days_tue, lead_time_days_wed,
         lead_time_days_thu, lead_time_days_fri, lead_time_days_sat,
         cutoff_hhmm_sun, cutoff_hhmm_mon, cutoff_hhmm_tue, cutoff_hhmm_wed,
         cutoff_hhmm_thu, cutoff_hhmm_fri, cutoff_hhmm_sat
  FROM vendor_weekly_rules
)
SELECT
  s.vendor_id AS vendor_id,
  s.destination_id AS destination_id,
  date(
    s.order_date,
    '+' || (
      CASE strftime('%w', s.order_date)
        WHEN '0' THEN COALESCE(v.lead_time_days_sun, 1)
        WHEN '1' THEN COALESCE(v.lead_time_days_mon, 1)
        WHEN '2' THEN COALESCE(v.lead_time_days_tue, 1)
        WHEN '3' THEN COALESCE(v.lead_time_days_wed, 1)
        WHEN '4' THEN COALESCE(v.lead_time_days_thu, 1)
        WHEN '5' THEN COALESCE(v.lead_time_days_fri, 1)
        WHEN '6' THEN COALESCE(v.lead_time_days_sat, 1)
      END
    ) || ' day'
  ) AS delivery_date,
  s.item_id AS item_id,
  SUM(s.qty) AS sum_qty,
  MAX(s.unit_price) AS unit_price,
  (CASE strftime('%w', s.order_date)
     WHEN '0' THEN COALESCE(v.cutoff_hhmm_sun, '00:00')
     WHEN '1' THEN COALESCE(v.cutoff_hhmm_mon, '00:00')
     WHEN '2' THEN COALESCE(v.cutoff_hhmm_tue, '00:00')
     WHEN '3' THEN COALESCE(v.cutoff_hhmm_wed, '00:00')
     WHEN '4' THEN COALESCE(v.cutoff_hhmm_thu, '00:00')
     WHEN '5' THEN COALESCE(v.cutoff_hhmm_fri, '00:00')
     WHEN '6' THEN COALESCE(v.cutoff_hhmm_sat, '00:00')
   END) AS cutoff_hhmm,
  (CASE strftime('%w', s.order_date)
     WHEN '0' THEN COALESCE(v.lead_time_days_sun, 1)
     WHEN '1' THEN COALESCE(v.lead_time_days_mon, 1)
     WHEN '2' THEN COALESCE(v.lead_time_days_tue, 1)
     WHEN '3' THEN COALESCE(v.lead_time_days_wed, 1)
     WHEN '4' THEN COALESCE(v.lead_time_days_thu, 1)
     WHEN '5' THEN COALESCE(v.lead_time_days_fri, 1)
     WHEN '6' THEN COALESCE(v.lead_time_days_sat, 1)
   END) AS lead_time_days
FROM src s
LEFT JOIN vwr v ON v.vendor_id = s.vendor_id
GROUP BY s.vendor_id, s.destination_id, delivery_date, s.item_id
-- HAVING time(?) > time(cutoff_hhmm)
ORDER BY vendor_id, destination_id, delivery_date, item_id
`;

// =======================================================================
// 発注 API（注文入力・履歴）
//   対応画面：
//     - App.tsx          … 当日分の発注入力・送信
//     - HistoryPage.tsx  … 発注履歴一覧・詳細・CSV 出力
//   関連テーブル：
//     - stores, vendors
//     - orders, order_lines
// =======================================================================

// ===== マスタ API =====

// === 発注：店舗マスタ（/stores）===
// App.tsx 起動時に店舗一覧を返す。
// 画面の「店舗」プルダウン＋モーダルで利用。
// 使用テーブル：stores（id, name）


app.get("/stores", (_req, res) => {
  try {
    const rows = db.prepare(`
      SELECT id, name
      FROM stores
      ORDER BY id
    `).all();
    res.json({ stores: rows });
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});

// === 発注・出荷共通：ベンダーマスタ（/vendors）===
// App.tsx 起動時にベンダー一覧を返す（発注画面のベンダーフィルタ等）。
// VendorShipments / VendorEdit でもベンダー選択用に利用。
// 使用テーブル：vendors（あれば優先）／無ければ item_prices の vendor_id DISTINCT

app.get("/vendors", (_req, res) => {
  try {
    let rows: { id: string; name: string }[] = [];

    if (hasTable("vendors")) {
      rows = db.prepare(`
        SELECT id, COALESCE(name, id) AS name
        FROM vendors
        ORDER BY id
      `).all() as { id: string; name: string }[];
    } else if (hasTable("item_prices")) {
      rows = db.prepare(`
        SELECT DISTINCT vendor_id AS id, vendor_id AS name
        FROM item_prices
        ORDER BY vendor_id
      `).all() as { id: string; name: string }[];
    }

    res.json({ vendors: rows });
  } catch (e:any) {
    res.status(500).json({ error: String(e?.message ?? e) });
  }
});

// 出荷用：品目マスタ
// GET /master/items
app.get("/master/items", (_req, res) => {
  try {
    const rows = db
      .prepare(`
        SELECT id, name, spec, unit, temp_zone AS tempZone
        FROM items
        ORDER BY id
      `)
      .all();
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// 出荷用：納品先マスタ（店舗）
// GET /master/stores
app.get("/master/stores", (_req, res) => {
  try {
    const rows = db
      .prepare("SELECT id, name FROM stores ORDER BY id")
      .all();
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// ベンダー別取扱品目（VendorEdit のモーダル用）
// GET /vendors/:id/items
app.get("/vendors/:id/items", (req, res) => {
  try {
    const vendorId = req.params.id;
    const rows = db
      .prepare(`
        SELECT i.id, i.name, i.spec, i.unit, i.temp_zone AS tempZone
          FROM vendor_items vi
          JOIN items i ON i.id = vi.item_id
         WHERE vi.vendor_id = @vendorId
         ORDER BY i.id
      `)
      .all({ vendorId });
    res.json(rows);
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// ===== 発注 API（注文入力・履歴） =====

// === 発注：入力画面の検索（/ordering/entry）===
// App.tsx の doSearch() から呼ばれるメインAPI。
// ・店舗名 storeName
// ・ベンダー一覧 vendors
// ・品目一覧 items（itemId, name, spec, unit, vendorId, unitPrice）
// ・ベンダー別の締め/リードタイム rules.perVendor
// ・draft や order があれば mergedLines として既存数量も返す
// 使用テーブル：
//   stores           … 店舗名取得
//   vendors          … ベンダー一覧
//   items, item_prices など … 発注候補品目＋単価
//   orders, order_lines, order_drafts … 既存発注・ドラフトのマージ

app.get("/ordering/entry", (req, res) => {
  try {
    const storeId = String(req.query.storeId ?? "");
    const orderDate = String(req.query.orderDate ?? "");

    // store 名
    const storeRow = db.prepare(`
      SELECT name FROM stores WHERE id = ?
    `).get(storeId) as { name?: string } | undefined;

    // ベンダー
    const vendors = db.prepare(`
      SELECT id, COALESCE(name, id) AS name
      FROM vendors
      ORDER BY id
    `).all() as { id: string; name: string }[];

        // ベンダー別ルール
    // 将来は vendor_weekly_rules から
    // { [vendorId]: { orderable, cutoffHHmm, leadTimeDays } } を構築する想定。
    type VendorRule = {
      orderable: boolean;
      cutoffHHmm: string | null;
      leadTimeDays: number | null;
    };
    const rulesPerVendor: Record<string, VendorRule> = {};

    // items: storeId, orderDate に紐づく品目＋単価一覧
    // 将来は item_prices × items から取得するが、今は空配列で型だけ合わせる。
    type EntryItem = {
      itemId: string;
      name: string | null;
      spec: string | null;
      unit: string | null;
      vendorId: string | null;
      unitPrice: number;
    };
    const items: EntryItem[] = [];

    // 既存ドラフトや確定済み注文などをマージして mergedLines に
    // 将来的に order_drafts / orders / order_lines をマージするが、ここでは空。
    type MergedLine = {
      vendorId: string | null;
      itemId: string;
      qty: number;
      unitPrice: number;
      amount: number;
    };
    const mergedLines: MergedLine[] = [];

    res.json({
      storeName: storeRow?.name ?? null,
      stores: db.prepare(`SELECT id, name FROM stores ORDER BY id`).all(),
      vendors,
      rules: { perVendor: rulesPerVendor },
      status: { editable: true, reason: "" }, // 過去日などで編集NGならここで false
      items,
      mergedLines,
      draft: { exists: false, lines: [] }, // 必要に応じて
      order: { exists: false, lines: [] }, // 必要に応じて
      vendorNames: Object.fromEntries(vendors.map(v => [v.id, v.name])),
      itemNames: Object.fromEntries(items.map((it: any) => [it.itemId, it.name])),
    });
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});

// === 発注：送信（/ordering/submit）===
// App.tsx の handleSend() から POST。
// 受け取る JSON: { storeId, vendorMode:"all", vendorId:null, orderDate, taxRate, lines:[...] }
// やること：
//  1. トランザクション開始
//  2. orders ヘッダに INSERT or UPDATE
//  3. order_lines を一旦削除してから INSERT し直し（置き換え保存）
//  4. 小計・税・合計を再計算して返却
// 使用テーブル：
//   orders       … store_id + vendor_id + order_date をキーとしたヘッダ UPSERT
//   order_lines  … 対象 order_id の明細を DELETE → INSERT で全置換
// 使用テーブル：orders, order_lines（集計のみ）
// 使用テーブル：orders, order_lines, items（JOIN して品目名取得）
// 使用テーブル：orders, order_lines, stores, vendors, items（CSV 用にフラット化）

app.post("/ordering/submit", (req, res) => {
  try {
    const body = req.body as SubmitDto; // 型イメージ

    const trx = db.transaction(() => {
      // 1) ヘッダを Upsert
      const headerStmt = db.prepare(`
        INSERT INTO orders (store_id, vendor_id, order_date, tax_rate)
        VALUES (@storeId, NULL, @orderDate, @taxRate)
        ON CONFLICT(store_id, vendor_id, order_date) DO UPDATE SET
          tax_rate = excluded.tax_rate,
          updated_at = CURRENT_TIMESTAMP
        RETURNING id
      `);
      const header = headerStmt.get({
        storeId: body.storeId,
        orderDate: body.orderDate,
        taxRate: body.taxRate,
      }) as { id: number };

      // 2) 明細全削除→再INSERT
      db.prepare(`DELETE FROM order_lines WHERE order_id = ?`).run(header.id);

      const insertLine = db.prepare(`
        INSERT INTO order_lines (order_id, item_id, qty, unit_price, amount, vendor_id)
        VALUES (@orderId, @itemId, @qty, @unitPrice, @amount, @vendorId)
      `);
      for (const ln of body.lines) {
        if (!ln.itemId || !Number.isFinite(ln.qty) || ln.qty <= 0) continue;
        insertLine.run({
          orderId: header.id,
          itemId: ln.itemId,
          qty: ln.qty,
          unitPrice: ln.unitPrice,
          amount: ln.qty * ln.unitPrice,
          vendorId: ln.vendorId,
        });
      }

      // 3) 合計計算
      const totals = db.prepare(`
        SELECT
          COALESCE(SUM(amount),0) AS subtotal,
          COALESCE(SUM(amount),0) * @taxRate AS tax,
          COALESCE(SUM(amount),0) * (1 + @taxRate) AS total
        FROM order_lines WHERE order_id = @orderId
      `).get({ orderId: header.id, taxRate: body.taxRate }) as {
        subtotal: number; tax: number; total: number;
      };

      return { orderId: header.id, totals };
    });

    const result = trx();
    res.json(result);
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});

// === 発注：履歴一覧（/ordering/list）===
// HistoryPage.tsx の load() から呼び出し。
// クエリ: storeId, start/from, end/to
// 戻り値: { total, items:[{id,storeId,vendorId,orderDate,lineCount,total}], summary:{total,count} }
app.get("/ordering/list", (req, res) => {
  try {
    const storeId = String(req.query.storeId ?? "");
    const from = String(req.query.start ?? req.query.from ?? "");
    const to = String(req.query.end ?? req.query.to ?? "");

    const rows = db.prepare(`
      SELECT
        o.id,
        o.store_id      AS storeId,
        o.vendor_id     AS vendorId,
        o.order_date    AS orderDate,
        COUNT(ol.id)    AS lineCount,
        COALESCE(SUM(ol.amount),0) AS total
      FROM orders o
      LEFT JOIN order_lines ol ON ol.order_id = o.id
      WHERE o.store_id = @storeId
        AND o.order_date BETWEEN @from AND @to
      GROUP BY o.id, o.store_id, o.vendor_id, o.order_date
      ORDER BY o.order_date DESC, o.id DESC
    `).all({ storeId, from, to }) as any[];

    const total = rows.length;
    const sumTotal = rows.reduce((s, r) => s + Number(r.total ?? 0), 0);

    res.json({
      total,
      items: rows,
      summary: { total: sumTotal, count: total },
    });
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});

// === 発注：詳細（/ordering/detail）===
// HistoryPage.tsx の openDetail() から呼ばれる。
// header + lines を返す（CSV と同じ集計形式）。
app.get("/ordering/detail", (req, res) => {
  try {
    const orderId = Number(req.query.orderId ?? 0);
    if (!orderId) { res.status(400).json({ error: "orderId required" }); return; }

    const header = db.prepare(`
      SELECT
        o.id,
        o.store_id AS storeId,
        o.vendor_id AS vendorId,
        o.order_date AS orderDate,
        o.expected_arrival_date AS expectedArrivalDate,
        COALESCE(SUM(ol.amount),0) AS subtotal,
        0 AS tax, -- 必要なら orders.tax_rate と掛け算
        COALESCE(SUM(ol.amount),0) AS total
      FROM orders o
      LEFT JOIN order_lines ol ON ol.order_id = o.id
      WHERE o.id = @orderId
    `).get({ orderId });

    const lines = db.prepare(`
      SELECT
        ol.item_id AS itemId,
        i.name     AS itemName,
        ol.qty,
        ol.unit_price AS unitPrice,
        ol.amount
      FROM order_lines ol
      LEFT JOIN items i ON i.id = ol.item_id
      WHERE ol.order_id = @orderId
      ORDER BY ol.item_id
    `).all({ orderId });

    res.json({ header, lines });
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});

// === 発注：明細CSVエクスポート（/ordering/export_lines）===
// HistoryPage.tsx の「CSVダウンロード」ボタンから呼ばれる。
// 期間内の注文を store/vendor/item 単位でフラットに返す。
app.get("/ordering/export_lines", (req, res) => {
  try {
    const storeId = String(req.query.storeId ?? "");
    const from = String(req.query.start ?? req.query.from ?? "");
    const to = String(req.query.end ?? req.query.to ?? "");

    const rows = db.prepare(`
      SELECT
        o.id              AS orderId,
        o.store_id        AS storeId,
        s.name            AS storeName,
        o.vendor_id       AS vendorId,
        v.name            AS vendorName,
        o.order_date      AS orderDate,
        ol.item_id        AS itemId,
        i.name            AS itemName,
        ol.qty            AS qty,
        ol.unit_price     AS unitPrice,
        ol.amount         AS amount
      FROM orders o
      JOIN order_lines ol ON ol.order_id = o.id
      LEFT JOIN stores  s ON s.id = o.store_id
      LEFT JOIN vendors v ON v.id = o.vendor_id
      LEFT JOIN items   i ON i.id = ol.item_id
      WHERE o.store_id = @storeId
        AND o.order_date BETWEEN @from AND @to
      ORDER BY o.order_date, o.id, ol.item_id
    `).all({ storeId, from, to });

    res.json({ items: rows });
  } catch (e:any) {
    res.status(500).json({ error: e.message });
  }
});


// =======================================================================
// 出荷 API（VendorShipments.tsx / VendorEdit.tsx）
//   対応画面：
//     - VendorShipments.tsx … 出荷一覧・確定・出荷生成
//     - VendorEdit.tsx      … 出荷伝票の新規・編集
//   関連テーブル：
//     - shipments, shipment_lines
//     - orders, order_lines（出荷生成元）
// =======================================================================

// === 出荷一覧検索（/shipments）===
// VendorShipments.tsx → doSearchWith()
// 検索条件：納品日 from/to, vendorId, destinationId
// 使用テーブル：shipments, shipment_lines
app.get("/shipments", (req, res) => {
  try {
    const from = String(req.query.from ?? "");
    const to = String(req.query.to ?? "");
    const vendorId = String(req.query.vendorId ?? "");
    const destinationId = String(req.query.destinationId ?? "");

    const headers = db.prepare(`
      SELECT
        h.id,
        h.delivery_date AS deliveryDate,
        h.vendor_id AS vendorId,
        v.name AS vendorName,
        h.destination_id AS destinationId,
        h.destination_name AS destinationName,
        h.status
      FROM shipments h
      LEFT JOIN vendors v ON v.id = h.vendor_id
      WHERE (h.delivery_date BETWEEN @from AND @to)
        AND (@vendorId = '' OR h.vendor_id = @vendorId)
        AND (@destinationId = '' OR h.destination_id = @destinationId)
      ORDER BY h.delivery_date DESC, h.id DESC
    `).all({ from, to, vendorId, destinationId });

    const lines = db.prepare(`
      SELECT
        l.id,
        l.header_id AS headerId,
        l.item_id AS itemId,
        i.name AS itemName,
        l.ship_qty AS shipQty,
        l.ordered_qty AS orderedQty,
        l.unit AS unit,
        l.spec AS spec,
        l.temp_zone AS tempZone,
        l.lot_no AS lotNo
      FROM shipment_lines l
      LEFT JOIN items i ON i.id = l.item_id
      WHERE l.header_id IN (SELECT id FROM shipments)
    `).all();

    res.json({ headers, lines });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷単票取得（/shipments/:id）===
// VendorEdit.tsx → getShipment()
// 使用テーブル：shipments, shipment_lines
app.get("/shipments/:id", (req, res) => {
  try {
    const id = req.params.id;
    const header = db.prepare(`
      SELECT
        h.id,
        h.vendor_id AS vendorId,
        v.name AS vendorName,
        h.destination_id AS destinationId,
        h.destination_name AS destinationName,
        h.delivery_date AS deliveryDate,
        h.status
      FROM shipments h
      LEFT JOIN vendors v ON v.id = h.vendor_id
      WHERE h.id = ?
    `).get(id);

    const lines = db.prepare(`
      SELECT
        l.id AS lineId,
        l.header_id AS headerId,
        l.item_id AS itemId,
        i.name AS itemName,
        l.unit AS unit,
        l.spec AS spec,
        l.temp_zone AS tempZone,
        l.ship_qty AS shipQty,
        l.ordered_qty AS orderedQty,
        l.note AS note,
        l.lot_no AS lotNo
      FROM shipment_lines l
      LEFT JOIN items i ON i.id = l.item_id
      WHERE l.header_id = ?
      ORDER BY l.id
    `).all(id);

    res.json({ header, lines });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷ヘッダ新規作成（/shipments）===
// VendorEdit.tsx → createShipment()
// 使用テーブル：shipments, shipment_lines
app.post("/shipments", (req, res) => {
  try {
    const body = req.body as {
      deliveryDate: string;
      vendorId: string;
      destinationId: string;
      destinationName?: string;
      lines: any[];
    };

    const trx = db.transaction(() => {
      const header = db
        .prepare(`
          INSERT INTO shipments (
            vendor_id, destination_id, destination_name, delivery_date, status, created_at, updated_at
          ) VALUES (
            @vendorId, @destinationId, @destinationName, @deliveryDate, 'open', datetime('now'), datetime('now')
          )
          RETURNING *
        `)
        .get(body) as any;

      const stmt = db.prepare(`
        INSERT INTO shipment_lines (
          header_id, item_id, unit, spec, temp_zone, ship_qty, note, lot_no
        ) VALUES (
          @headerId, @itemId, @unit, @spec, @tempZone, @shipQty, @note, @lotNo
        )
      `);

      for (const ln of body.lines) {
        stmt.run({
          headerId: header.id,
          itemId: ln.itemId,
          unit: ln.unit ?? "",
          spec: ln.spec ?? "",
          tempZone: ln.tempZone ?? null,
          shipQty: ln.shipQty ?? 0,
          note: ln.note ?? "",
          lotNo: ln.lotNo ?? "",
        });
      }

      return header;
    });

    const header = trx();
    res.json({ ok: true, header });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷ヘッダ更新（/shipments/:id）===
// VendorEdit.tsx → updateShipmentHeader()
// 使用テーブル：shipments
app.post("/shipments/:id", (req, res) => {
  try {
    const id = req.params.id;
    const body = req.body as {
      deliveryDate: string;
      vendorId: string;
      destinationId: string;
      destinationName?: string;
    };
    db.prepare(`
      UPDATE shipments
      SET delivery_date = @deliveryDate,
          vendor_id = @vendorId,
          destination_id = @destinationId,
          destination_name = @destinationName,
          updated_at = datetime('now')
      WHERE id = @id
    `).run({ ...body, id });
    res.json({ ok: true });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷明細置換保存（/shipments/:id/lines/replace）===
// VendorEdit.tsx → replaceLines()
// 使用テーブル：shipment_lines
app.post("/shipments/:id/lines/replace", (req, res) => {
  try {
    const id = req.params.id;
    const lines = req.body as any[];

    const trx = db.transaction(() => {
      db.prepare(`DELETE FROM shipment_lines WHERE header_id = ?`).run(id);
      const stmt = db.prepare(`
        INSERT INTO shipment_lines (
          header_id, item_id, unit, spec, temp_zone, ship_qty, note, lot_no
        ) VALUES (
          @headerId, @itemId, @unit, @spec, @tempZone, @shipQty, @note, @lotNo
        )
      `);
      for (const ln of lines) {
        stmt.run({
          headerId: id,
          itemId: ln.itemId,
          unit: ln.unit ?? "",
          spec: ln.spec ?? "",
          tempZone: ln.tempZone ?? null,
          shipQty: ln.shipQty ?? 0,
          note: ln.note ?? "",
          lotNo: ln.lotNo ?? "",
        });
      }
    });
    trx();

    res.json({ ok: true });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷確定・取消 ===
// VendorShipments.tsx → handleConfirm(), handleUnconfirm()
// 使用テーブル：shipments
app.post("/shipments/confirm", (req, res) => {
  try {
    const ids = req.body as string[];
    const stmt = db.prepare(`
      UPDATE shipments
      SET status = 'confirmed', updated_at = datetime('now')
      WHERE id = ?
    `);
    const trx = db.transaction(() => {
      for (const id of ids) stmt.run(id);
    });
    trx();
    res.json({ ok: true, updated: ids.length });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

app.post("/shipments/unconfirm", (req, res) => {
  try {
    const ids = req.body as string[];
    const stmt = db.prepare(`
      UPDATE shipments
      SET status = 'open', updated_at = datetime('now')
      WHERE id = ?
    `);
    const trx = db.transaction(() => {
      for (const id of ids) stmt.run(id);
    });
    trx();
    res.json({ ok: true, updated: ids.length });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});


// === 出荷生成（プレビュー／本生成）===
// VendorShipments.tsx → generateShipments()
// 使用テーブル：orders, order_lines → shipments, shipment_lines へ集計転記
app.post("/shipments/generate/preview", (req, res) => {
  try {
    const now = new Date().toISOString().slice(11, 16);
    const rows = db.prepare(AGG_SQL).all(); // AGG_SQL は既存の集計SQL
    res.json({
      ok: true,
      nowHHmm: now,
      countHeaders: rows.length,
      countLines: rows.reduce((s: number, r: any) => s + 1, 0),
    });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

app.post("/shipments/generate", (req, res) => {
  try {
    const rows = db.prepare(AGG_SQL).all();
    const trx = db.transaction(() => {
      let headerCount = 0;
      let lineCount = 0;
      for (const r of rows as any[]) {
        const header = db
          .prepare(`
            INSERT INTO shipments (
              vendor_id, destination_id, destination_name, delivery_date, status, created_at, updated_at
            ) VALUES (
              @vendor_id, @destination_id, NULL, @delivery_date, 'open', datetime('now'), datetime('now')
            )
            ON CONFLICT(vendor_id, destination_id, delivery_date)
            DO UPDATE SET updated_at = datetime('now')
            RETURNING id
          `)
          .get(r) as any;
        headerCount++;

        db.prepare(`
          INSERT INTO shipment_lines (
            header_id, item_id, ship_qty, unit_price
          ) VALUES (
            @headerId, @item_id, @sum_qty, @unit_price
          )
        `).run({
          headerId: header.id,
          item_id: r.item_id,
          sum_qty: r.sum_qty,
          unit_price: r.unit_price,
        });
        lineCount++;
      }
      return { headerCount, lineCount };
    });

    const { headerCount, lineCount } = trx();
    res.json({ ok: true, headersAffected: headerCount, linesAffected: lineCount });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// // 受注→出荷の集計（orders.order_date / order_lines.qty, unit_price を使用）
// // vendor_weekly_rules は曜日別カラム *_sun..*_sat から CASE で取得
// const AGG_SQL = `
// WITH src AS (
//   SELECT
//     COALESCE(o.vendor_id, ol.vendor_id) AS vendor_id,
//     o.store_id                           AS destination_id,  -- ← ここを固定
//     o.order_date                         AS order_date,
//     ol.item_id                           AS item_id,
//     COALESCE(ol.qty, 0)                  AS qty,
//     COALESCE(ol.unit_price, 0)           AS unit_price
//   FROM orders o
//   JOIN order_lines ol ON ol.order_id = o.id
// ),
// vwr AS (
//   SELECT vendor_id,
//          lead_time_days_sun, lead_time_days_mon, lead_time_days_tue, lead_time_days_wed,
//          lead_time_days_thu, lead_time_days_fri, lead_time_days_sat,
//          cutoff_hhmm_sun, cutoff_hhmm_mon, cutoff_hhmm_tue, cutoff_hhmm_wed,
//          cutoff_hhmm_thu, cutoff_hhmm_fri, cutoff_hhmm_sat
//   FROM vendor_weekly_rules
// )
// SELECT
//   s.vendor_id AS vendor_id,
//   s.destination_id AS destination_id,
//   date(
//     s.order_date,
//     '+' || (
//       CASE strftime('%w', s.order_date)
//         WHEN '0' THEN COALESCE(v.lead_time_days_sun, 1)
//         WHEN '1' THEN COALESCE(v.lead_time_days_mon, 1)
//         WHEN '2' THEN COALESCE(v.lead_time_days_tue, 1)
//         WHEN '3' THEN COALESCE(v.lead_time_days_wed, 1)
//         WHEN '4' THEN COALESCE(v.lead_time_days_thu, 1)
//         WHEN '5' THEN COALESCE(v.lead_time_days_fri, 1)
//         WHEN '6' THEN COALESCE(v.lead_time_days_sat, 1)
//       END
//     ) || ' day'
//   ) AS delivery_date,
//   s.item_id AS item_id,
//   SUM(s.qty) AS sum_qty,
//   MAX(s.unit_price) AS unit_price,
//   (CASE strftime('%w', s.order_date)
//      WHEN '0' THEN COALESCE(v.cutoff_hhmm_sun, '00:00')
//      WHEN '1' THEN COALESCE(v.cutoff_hhmm_mon, '00:00')
//      WHEN '2' THEN COALESCE(v.cutoff_hhmm_tue, '00:00')
//      WHEN '3' THEN COALESCE(v.cutoff_hhmm_wed, '00:00')
//      WHEN '4' THEN COALESCE(v.cutoff_hhmm_thu, '00:00')
//      WHEN '5' THEN COALESCE(v.cutoff_hhmm_fri, '00:00')
//      WHEN '6' THEN COALESCE(v.cutoff_hhmm_sat, '00:00')
//    END) AS cutoff_hhmm,
//   (CASE strftime('%w', s.order_date)
//      WHEN '0' THEN COALESCE(v.lead_time_days_sun, 1)
//      WHEN '1' THEN COALESCE(v.lead_time_days_mon, 1)
//      WHEN '2' THEN COALESCE(v.lead_time_days_tue, 1)
//      WHEN '3' THEN COALESCE(v.lead_time_days_wed, 1)
//      WHEN '4' THEN COALESCE(v.lead_time_days_thu, 1)
//      WHEN '5' THEN COALESCE(v.lead_time_days_fri, 1)
//      WHEN '6' THEN COALESCE(v.lead_time_days_sat, 1)
//    END) AS lead_time_days
// FROM src s
// LEFT JOIN vwr v ON v.vendor_id = s.vendor_id
// GROUP BY s.vendor_id, s.destination_id, delivery_date, s.item_id
// -- HAVING time(?) > time(cutoff_hhmm)
// ORDER BY vendor_id, destination_id, delivery_date, item_id
// `;

// GET /__tables
// テーブル一覧確認用
app.get("/__tables", (_req, res) => {
  const rows = db.prepare(`
    SELECT type, name
    FROM sqlite_master
    WHERE type IN ('table','index')
    ORDER BY type, name
  `).all();
  res.json({ rows });
});

// GET /__debug/master
// items/stores 件数などの簡易チェック
app.get("/__debug/master", (_req, res) => {
  try {
    const items = db.prepare("SELECT COUNT(*) AS c FROM items").get() as { c: number };
    const stores = db.prepare("SELECT COUNT(*) AS c FROM stores").get() as { c: number };
    res.json({
      ok: true,
      itemsCount: items?.c ?? 0,
      storesCount: stores?.c ?? 0,
      ts: new Date().toISOString(),
    });
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

// ====== Start ======
const PORT = Number(process.env.PORT || 8080);

app.listen(PORT, () => {
  console.log(`[server] listening on http://localhost:${PORT}  (db=${DB_PATH})`);
});
